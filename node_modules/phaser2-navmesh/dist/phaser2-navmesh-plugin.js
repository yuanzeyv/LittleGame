!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.Phaser2NavMeshPlugin=n():t.Phaser2NavMeshPlugin=n()}(self,(function(){return(()=>{var t={774:(t,n)=>{var s,e,i,o;o=function(){function t(t){for(var n=t,s=[];n.parent;)s.unshift(n),n=n.parent;return s}var n={search:function(s,e,o,r){s.cleanDirty();var h=(r=r||{}).heuristic||n.heuristics.manhattan,a=r.closest||!1,c=new i((function(t){return t.f})),l=e;for(e.h=h(e,o),s.markDirty(e),c.push(e);c.size()>0;){var u=c.pop();if(u===o)return t(u);u.closed=!0;for(var d=s.neighbors(u),p=0,g=d.length;p<g;++p){var y=d[p];if(!y.closed&&!y.isWall()){var f=u.g+y.getCost(u),b=y.visited;(!b||f<y.g)&&(y.visited=!0,y.parent=u,y.h=y.h||h(y,o),y.g=f,y.f=y.g+y.h,s.markDirty(y),a&&(y.h<l.h||y.h===l.h&&y.g<l.g)&&(l=y),b?c.rescoreElement(y):c.push(y))}}}return a?t(l):[]},heuristics:{manhattan:function(t,n){return Math.abs(n.x-t.x)+Math.abs(n.y-t.y)},diagonal:function(t,n){var s=Math.sqrt(2),e=Math.abs(n.x-t.x),i=Math.abs(n.y-t.y);return 1*(e+i)+(s-2)*Math.min(e,i)}},cleanNode:function(t){t.f=0,t.g=0,t.h=0,t.visited=!1,t.closed=!1,t.parent=null}};function s(t,n){n=n||{},this.nodes=[],this.diagonal=!!n.diagonal,this.grid=[];for(var s=0;s<t.length;s++){this.grid[s]=[];for(var i=0,o=t[s];i<o.length;i++){var r=new e(s,i,o[i]);this.grid[s][i]=r,this.nodes.push(r)}}this.init()}function e(t,n,s){this.x=t,this.y=n,this.weight=s}function i(t){this.content=[],this.scoreFunction=t}return s.prototype.init=function(){this.dirtyNodes=[];for(var t=0;t<this.nodes.length;t++)n.cleanNode(this.nodes[t])},s.prototype.cleanDirty=function(){for(var t=0;t<this.dirtyNodes.length;t++)n.cleanNode(this.dirtyNodes[t]);this.dirtyNodes=[]},s.prototype.markDirty=function(t){this.dirtyNodes.push(t)},s.prototype.neighbors=function(t){var n=[],s=t.x,e=t.y,i=this.grid;return i[s-1]&&i[s-1][e]&&n.push(i[s-1][e]),i[s+1]&&i[s+1][e]&&n.push(i[s+1][e]),i[s]&&i[s][e-1]&&n.push(i[s][e-1]),i[s]&&i[s][e+1]&&n.push(i[s][e+1]),this.diagonal&&(i[s-1]&&i[s-1][e-1]&&n.push(i[s-1][e-1]),i[s+1]&&i[s+1][e-1]&&n.push(i[s+1][e-1]),i[s-1]&&i[s-1][e+1]&&n.push(i[s-1][e+1]),i[s+1]&&i[s+1][e+1]&&n.push(i[s+1][e+1])),n},s.prototype.toString=function(){for(var t=[],n=this.grid,s=0;s<n.length;s++){for(var e=[],i=n[s],o=0;o<i.length;o++)e.push(i[o].weight);t.push(e.join(" "))}return t.join("\n")},e.prototype.toString=function(){return"["+this.x+" "+this.y+"]"},e.prototype.getCost=function(t){return t&&t.x!=this.x&&t.y!=this.y?1.41421*this.weight:this.weight},e.prototype.isWall=function(){return 0===this.weight},i.prototype={push:function(t){this.content.push(t),this.sinkDown(this.content.length-1)},pop:function(){var t=this.content[0],n=this.content.pop();return this.content.length>0&&(this.content[0]=n,this.bubbleUp(0)),t},remove:function(t){var n=this.content.indexOf(t),s=this.content.pop();n!==this.content.length-1&&(this.content[n]=s,this.scoreFunction(s)<this.scoreFunction(t)?this.sinkDown(n):this.bubbleUp(n))},size:function(){return this.content.length},rescoreElement:function(t){this.sinkDown(this.content.indexOf(t))},sinkDown:function(t){for(var n=this.content[t];t>0;){var s=(t+1>>1)-1,e=this.content[s];if(!(this.scoreFunction(n)<this.scoreFunction(e)))break;this.content[s]=n,this.content[t]=e,t=s}},bubbleUp:function(t){for(var n=this.content.length,s=this.content[t],e=this.scoreFunction(s);;){var i,o=t+1<<1,r=o-1,h=null;if(r<n){var a=this.content[r];(i=this.scoreFunction(a))<e&&(h=r)}if(o<n){var c=this.content[o];this.scoreFunction(c)<(null===h?e:i)&&(h=o)}if(null===h)break;this.content[t]=this.content[h],this.content[h]=s,t=h}}},{astar:n,Graph:s}},"object"==typeof t.exports?t.exports=o():(e=[],void 0===(i="function"==typeof(s=o)?s.apply(void 0,e):s)||(t.exports=i))}},n={};function s(e){var i=n[e];if(void 0!==i)return i.exports;var o=n[e]={exports:{}};return t[e](o,o.exports,s),o.exports}s.n=t=>{var n=t&&t.__esModule?()=>t.default:()=>t;return s.d(n,{a:n}),n},s.d=(t,n)=>{for(var e in n)s.o(n,e)&&!s.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:n[e]})},s.o=(t,n)=>Object.prototype.hasOwnProperty.call(t,n),s.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var e={};return(()=>{"use strict";s.r(e),s.d(e,{Phaser2NavMesh:()=>g,Phaser2NavMeshPlugin:()=>y,default:()=>f});var t=s(774),n=s.n(t);class i{x;y;constructor(t=0,n=0){this.x=t,this.y=n}equals(t){return this.x===t.x&&this.y===t.y}angle(t){return Math.atan2(t.y-this.y,t.x-this.x)}distance(t){const n=t.x-this.x,s=t.y-this.y;return Math.sqrt(n*n+s*s)}add(t){this.x+=t.x,this.y+=t.y}subtract(t){this.x-=t.x,this.y-=t.y}clone(){return new i(this.x,this.y)}}class o{id;polygon;edges;neighbors;portals;centroid;boundingRadius;weight=1;x=0;y=0;constructor(t,n){this.id=t,this.polygon=n,this.edges=n.edges,this.neighbors=[],this.portals=[],this.centroid=this.calculateCentroid(),this.boundingRadius=this.calculateRadius()}getPoints(){return this.polygon.points}contains(t){return this.polygon.contains(t.x,t.y)||this.isPointOnEdge(t)}calculateCentroid(){const t=new i(0,0),n=this.polygon.points.length;return this.polygon.points.forEach((n=>t.add(n))),t.x/=n,t.y/=n,t}calculateRadius(){let t=0;for(const n of this.polygon.points){const s=this.centroid.distance(n);s>t&&(t=s)}return t}isPointOnEdge({x:t,y:n}){for(const s of this.edges)if(s.pointOnSegment(t,n))return!0;return!1}destroy(){this.neighbors=[],this.portals=[]}toString(){return`NavPoly(id: ${this.id} at: ${this.centroid})`}isWall(){return 0===this.weight}centroidDistance(t){return this.centroid.distance(t.centroid)}getCost(t){return this.centroidDistance(t)}}function r(t,n){const s=n.start,e=n.end,o=function(t,n){const s=n.x-t.x,e=n.y-t.y;return s*s+e*e}(s,e);let r=((t.x-s.x)*(e.x-s.x)+(t.y-s.y)*(e.y-s.y))/o;var h;return(h=r)<0&&(h=0),h>1&&(h=1),r=h,new i(s.x+r*(e.x-s.x),s.y+r*(e.y-s.y))}function h(t,n,s){const e=n.x-t.x,i=n.y-t.y;return(s.x-t.x)*i-e*(s.y-t.y)}function a(t,n,s=1e-4){return Math.abs(t-n)<=s}function c(t,n){let s=t-n;const e=s+Math.PI,i=2*Math.PI;return s=e-Math.floor(e/i)*i,s-=Math.PI,s}function l(t,n,s=1e-4){const e=h(t.start,t.end,n.start),i=h(t.start,t.end,n.end);return!(!a(e,0,s)||!a(i,0,s))}class u{path;portals;constructor(){this.portals=[],this.path=[]}push(t,n){void 0===n&&(n=t),this.portals.push({left:t,right:n})}stringPull(){const t=this.portals,n=[];let s=0,e=0,i=0,o=t[0].left,r=t[0].left,a=t[0].right;n.push(o);for(var c=1;c<t.length;c++){const l=t[c].left,u=t[c].right;if(h(o,a,u)<=0){if(!(o.equals(a)||h(o,r,u)>0)){n.push(r),o=r,s=e,r=o,a=o,e=s,i=s,c=s;continue}a=u,i=c}if(h(o,r,l)>=0){if(!(o.equals(r)||h(o,a,l)<0)){n.push(a),o=a,s=i,r=o,a=o,e=s,i=s,c=s;continue}r=l,e=c}}return 0!==n.length&&n[n.length-1].equals(t[t.length-1].left)||n.push(t[t.length-1].left),this.path=n,n}}class d{start;end;left;right;top;bottom;constructor(t,n,s,e){this.start=new i(t,n),this.end=new i(s,e),this.left=Math.min(t,s),this.right=Math.max(t,s),this.top=Math.min(n,e),this.bottom=Math.max(n,e)}pointOnSegment(t,n){return t>=this.left&&t<=this.right&&n>=this.top&&n<=this.bottom&&this.pointOnLine(t,n)}pointOnLine(t,n){return(t-this.left)*(this.bottom-this.top)==(this.right-this.left)*(n-this.top)}}class p{edges;points;isClosed;constructor(t,n=!0){this.isClosed=n,this.points=t,this.edges=[];for(let n=1;n<t.length;n++){const s=t[n-1],e=t[n];this.edges.push(new d(s.x,s.y,e.x,e.y))}if(this.isClosed){const n=t[0],s=t[t.length-1];this.edges.push(new d(n.x,n.y,s.x,s.y))}}contains(t,n){let s=!1;for(let e=-1,i=this.points.length-1;++e<this.points.length;i=e){const o=this.points[e].x,r=this.points[e].y,h=this.points[i].x,a=this.points[i].y;(r<=n&&n<a||a<=n&&n<r)&&t<(h-o)*(n-r)/(a-r)+o&&(s=!s)}return s}}class g{key;plugin;game;debugGraphics;navMesh;constructor(t,s,e,h=0){this.key=s,this.plugin=t,this.game=t.game,this.debugGraphics=null,this.navMesh=new class{meshShrinkAmount;navPolygons;graph;constructor(t,s=0){this.meshShrinkAmount=s;const e=t.map((t=>{const n=t.map((t=>new i(t.x,t.y)));return new p(n)}));this.navPolygons=e.map(((t,n)=>new o(n,t))),this.calculateNeighbors(),this.graph=new class{nodes;grid=[];constructor(t){this.nodes=t,this.init()}neighbors(t){return t.neighbors}navHeuristic(t,n){return t.centroidDistance(n)}destroy(){this.cleanDirty(),this.nodes=[]}init=n().Graph.prototype.init.bind(this);cleanDirty=n().Graph.prototype.cleanDirty.bind(this);markDirty=n().Graph.prototype.markDirty.bind(this);toString=n().Graph.prototype.toString.bind(this)}(this.navPolygons)}getPolygons(){return this.navPolygons}destroy(){this.graph.destroy();for(const t of this.navPolygons)t.destroy();this.navPolygons=[]}isPointInMesh(t){return this.navPolygons.some((n=>n.contains(t)))}findClosestMeshPoint(t,n=Number.POSITIVE_INFINITY){let s=n,e=null,i=null;for(const n of this.navPolygons){if(n.contains(t)){s=0,e=n,i=t;break}const o=n.boundingRadius;if(n.centroid.distance(t)-o<s){const o=this.projectPointToPolygon(t,n);o.distance<s&&(s=o.distance,e=n,i=o.point)}}return{distance:s,polygon:e,point:i}}findPath(t,s){let e,o,r=null,h=null,a=Number.MAX_VALUE,c=Number.MAX_VALUE;const l=new i(t.x,t.y),d=new i(s.x,s.y);for(const t of this.navPolygons)o=t.boundingRadius,e=t.centroid.distance(l),e<=a&&e<=o&&t.contains(l)&&(r=t,a=e),e=t.centroid.distance(d),e<=c&&e<=o&&t.contains(d)&&(h=t,c=e);if(!h&&this.meshShrinkAmount>0)for(const t of this.navPolygons)if(o=t.boundingRadius+this.meshShrinkAmount,e=t.centroid.distance(d),e<=o){const{distance:n}=this.projectPointToPolygon(d,t);n<=this.meshShrinkAmount&&n<c&&(h=t,c=n)}if(!h)return null;if(!r&&this.meshShrinkAmount>0)for(const t of this.navPolygons)if(o=t.boundingRadius+this.meshShrinkAmount,e=t.centroid.distance(l),e<=o){const{distance:n}=this.projectPointToPolygon(l,t);n<=this.meshShrinkAmount&&n<a&&(r=t,a=n)}if(!r)return null;if(r===h)return[l,d];const p=n().astar.search(this.graph,r,h,{heuristic:this.graph.navHeuristic});if(0===p.length)return null;p.unshift(r);const g=new u;g.push(l);for(let t=0;t<p.length-1;t++){const n=p[t],s=p[t+1];let e=null;for(let t=0;t<n.neighbors.length;t++)n.neighbors[t].id===s.id&&(e=n.portals[t]);if(!e)throw new Error("Path was supposed to be found, but portal is missing!");g.push(e.start,e.end)}g.push(d),g.stringPull();let y=null;const f=[];for(const t of g.path){const n=t.clone();y&&n.equals(y)||f.push(n),y=n}return f}calculateNeighbors(){for(let t=0;t<this.navPolygons.length;t++){const n=this.navPolygons[t];for(let s=t+1;s<this.navPolygons.length;s++){const t=this.navPolygons[s];if(!(n.centroid.distance(t.centroid)>n.boundingRadius+t.boundingRadius))for(const s of n.edges)for(const e of t.edges){if(!l(s,e))continue;const i=this.getSegmentOverlap(s,e);if(!i)continue;n.neighbors.push(t),t.neighbors.push(n);const[o,r]=i;let h=n.centroid.angle(s.start),a=n.centroid.angle(i[0]),u=n.centroid.angle(i[1]),p=c(h,a),g=c(h,u);p<g?n.portals.push(new d(o.x,o.y,r.x,r.y)):n.portals.push(new d(r.x,r.y,o.x,o.y)),h=t.centroid.angle(e.start),a=t.centroid.angle(i[0]),u=t.centroid.angle(i[1]),p=c(h,a),g=c(h,u),p<g?t.portals.push(new d(o.x,o.y,r.x,r.y)):t.portals.push(new d(r.x,r.y,o.x,o.y))}}}}getSegmentOverlap(t,n){const s=[{line:t,point:t.start},{line:t,point:t.end},{line:n,point:n.start},{line:n,point:n.end}];s.sort((function(t,n){return t.point.x<n.point.x?-1:t.point.x>n.point.x?1:t.point.y<n.point.y?-1:t.point.y>n.point.y?1:0}));const e=s[0].line===s[1].line,i=s[1].point.equals(s[2].point);return e||i?null:[s[1].point,s[2].point]}projectPointToPolygon(t,n){let s=null,e=Number.MAX_VALUE;for(const i of n.edges){const n=r(t,i),o=t.distance(n);(null===s||o<e)&&(e=o,s=n)}return{point:s,distance:e}}}(e,h)}isPointInMesh(t){return this.navMesh.isPointInMesh(t)}findPath(t,n,s=Phaser.Point){const e=this.navMesh.findPath(t,n);return e?e.map((({x:t,y:n})=>new s(t,n))):e}enableDebug(t){return t||this.debugGraphics?t&&(this.debugGraphics&&this.debugGraphics.destroy(),this.debugGraphics=t):this.debugGraphics=this.game.add.graphics(),this.debugGraphics&&(this.debugGraphics.visible=!0),this.debugGraphics}disableDebug(){this.debugGraphics&&(this.debugGraphics.visible=!1)}isDebugEnabled(){return this.debugGraphics&&this.debugGraphics.visible}debugDrawClear(){this.debugGraphics&&this.debugGraphics.clear()}debugDrawMesh({drawCentroid:t=!0,drawBounds:n=!1,drawNeighbors:s=!0,drawPortals:e=!0,palette:i=[41136,6965820,13382463,15427649,15583569]}={}){if(!this.debugGraphics)return;const o=this.debugGraphics;this.navMesh.getPolygons().forEach((r=>{const h=i[r.id%i.length];if(o.lineWidth=0,o.beginFill(h),o.drawPolygon(new Phaser.Polygon(...r.getPoints())),o.endFill(),t&&(o.beginFill(0),o.drawEllipse(r.centroid.x,r.centroid.y,4,4),o.endFill()),n){o.lineStyle(1,16777215);const t=r.boundingRadius;o.drawEllipse(r.centroid.x,r.centroid.y,t,t)}s&&(o.lineStyle(2,0),r.neighbors.forEach((t=>{o.moveTo(r.centroid.x,r.centroid.y),o.lineTo(t.centroid.x,t.centroid.y)}))),e&&(o.lineStyle(10,0),r.portals.forEach((t=>{o.moveTo(t.start.x,t.start.y),o.lineTo(t.end.x,t.end.y)})))}))}debugDrawPath(t,n=65280,s=10,e=1){if(this.debugGraphics&&t&&t.length){this.debugGraphics.lineStyle(s,n,e),this.debugGraphics.drawShape(new Phaser.Polygon(...t)),this.debugGraphics.beginFill(n,e);const i=.5*s;if(this.debugGraphics.drawEllipse(t[0].x,t[0].y,i,i),t.length>1){const n=t[t.length-1];this.debugGraphics.drawEllipse(n.x,n.y,i,i)}this.debugGraphics.endFill()}}destroy(){this.navMesh&&this.navMesh.destroy(),this.debugGraphics&&this.debugGraphics.destroy(),this.plugin.removeMesh(this.key)}}class y extends Phaser.Plugin{phaserNavMeshes={};constructor(t,n){super(t,n)}destroy(){this.removeAllMeshes()}removeAllMeshes(){const t=Object.values(this.phaserNavMeshes);this.phaserNavMeshes={},t.forEach((t=>t.destroy()))}removeMesh(t){this.phaserNavMeshes[t]&&delete this.phaserNavMeshes[t]}buildMeshFromTiled(t,n,s=0){if(this.phaserNavMeshes[t])return console.warn(`NavMeshPlugin: a navmesh already exists with the given key: ${t}`),this.phaserNavMeshes[t];n&&0!==n.length||console.warn(`NavMeshPlugin: The given tilemap object layer is empty or undefined: ${n}`);const e=(n||[]).map((t=>{const n=t.y,s=t.y+t.height,e=t.x,i=t.x+t.width;return[{x:e,y:n},{x:e,y:s},{x:i,y:s},{x:i,y:n}]})),i=new g(this,t,e,s);return this.phaserNavMeshes[t]=i,i}}const f=y})(),e})()}));
//# sourceMappingURL=phaser2-navmesh-plugin.js.map